section .data
    result_msg db "Result = ", 0    ; Повідомлення для виводу
    result_len equ $ - result_msg   ; Довжина повідомлення

section .bss
    result resb 4                   ; Буфер для результату (якщо потрібно вивести число)

section .text
    global _start

_start:
    ; Припустимо, що a, b, c вже збережені в регістрах eax, ebx, ecx відповідно
    mov eax, 5    ; a = 5
    mov ebx, 10   ; b = 10
    mov ecx, 3    ; c = 3

    ; Виконуємо b - c
    sub ebx, ecx  ; ebx = b - c

    ; Додаємо a до результату
    add ebx, eax  ; ebx = (b - c) + a

    ; Конвертуємо результат у текстовий формат
    mov eax, ebx  ; Переносимо результат в eax
    call int_to_ascii ; Перетворюємо результат в ASCII і записуємо в буфер

    ; Виводимо текст "Result = "
    mov eax, 4            ; Системний виклик для запису (sys_write)
    mov ebx, 1            ; Файловий дескриптор (1 - стандартний вивід)
    mov ecx, result_msg   ; Вказівник на повідомлення
    mov edx, result_len   ; Довжина повідомлення
    int 0x80              ; Виконання системного виклику

    ; Виводимо результат
    mov eax, 4            ; Системний виклик для запису (sys_write)
    mov ebx, 1            ; Файловий дескриптор (1 - стандартний вивід)
    mov ecx, result       ; Вказівник на результат
    mov edx, 4            ; Максимальна довжина числа (максимум 4 цифри для 32-бітного числа)
    int 0x80              ; Виконання системного виклику

    ; Завершуємо програму
    mov eax, 1            ; Системний виклик exit
    xor ebx, ebx          ; Статус завершення = 0
    int 0x80              ; Виконання системного виклику

int_to_ascii:
    ; Конвертація числа з eax у текстовий формат (ASCII) та збереження у буфері result
    mov edi, result       ; Вказівник на буфер
    mov ecx, 10           ; Дільник 10
    mov ebx, 0            ; Лічильник символів

.convert_loop:
    xor edx, edx          ; Очищення edx перед діленням
    div ecx               ; Ділимо eax на 10
    add dl, '0'           ; Конвертуємо залишок у ASCII
    mov [edi+ebx], dl     ; Записуємо символ у буфер
    inc ebx               ; Збільшуємо лічильник
    test eax, eax         ; Перевіряємо, чи залишився ще результат
    jnz .convert_loop     ; Якщо так, повторюємо

    ; Зворотній порядок запису (перевертаємо число)
    mov ecx, ebx          ; Довжина числа
    dec ecx               ; Зміщуємо на останній символ
.reverse_loop:
    mov al, [edi+ecx]     ; Читаємо символ з кінця
    mov [edi], al         ; Пишемо символ на початок
    inc edi               ; Зміщуємося вперед
    loop .reverse_loop    ; Повторюємо, поки не досягнемо початку
    ret                   ; Повернення з функції
